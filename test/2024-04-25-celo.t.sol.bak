// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.15;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import { PRBTest } from "@prb/test/PRBTest.sol";
import { console2 } from "forge-std/console2.sol";
import { StdCheats } from "forge-std/StdCheats.sol";
import { ISETH } from "@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol";
import { IWETH9 } from "@uniswap/v3-periphery/contracts/interfaces/external/IWETH9.sol";

import { ILiquidityMover, UniswapLiquidityMover, IUniswapSwapRouter, Torex, Config } from "../src/LiquidityMover.sol";

import { ISuperToken } from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol";

// NOTE: Can't run these tests because Foundry has problems with the CELO token (it's a so-called precompiled contract).

contract LiquidityMoverTests is PRBTest {
    UniswapLiquidityMover internal sut;

    IERC20 internal constant CELOx = IERC20(0x671425Ae1f272Bc6F79beC3ed5C4b00e9c628240);
    IERC20 internal constant CELO = IERC20(0x471EcE3750Da237f93B8E339c536989b8978a438);

    IERC20 internal constant cUSDx = IERC20(0x3AcB9A08697b6Db4cD977e8Ab42b6f24722e6D6e);
    IERC20 internal constant cUSD = IERC20(0x765DE816845861e75A25fCA122bb6898B8B1282a);

    function setUp() public {
        // Otherwise, run the test against the mainnet fork.
        // todo: env variable
        vm.createSelectFork({ urlOrAlias: "https://forno.celo.org", blockNumber: 25_292_105 });

        sut = new UniswapLiquidityMover(
            IUniswapSwapRouter(0x5615CDAb10dc425a742d643d949a7F474C01abc4), // "SwapRouter02"! (not just "SwapRouter")
            ISETH(address(CELOx)), // The Super Token on for Native Asset on Celo
            IERC20(address(CELO))
        );
    }

    function test_CELOx_to_cUSDx() external {
        Torex torex = Torex(0x5732b069F48B8c7e7C7eac5fB40f22aE31C03f1b);
        _testTorex(torex, address(CELO));
    }

    function test_cUSDx_to_CELOx() external {
        _testTorex(Torex(0x83848A4e12CeB4A5292c1E3Df2042a864A239724), address(cUSD));
    }

    function _testTorex(Torex torex, address rewardToken) internal {
        assertTrue(sut.moveLiquidity(torex));

        ISuperToken outToken = torex.getConfig().outToken;
        assertEq(outToken.balanceOf(address(sut)), 0);
        address outTokenUnderlying = outToken.getUnderlyingToken();
        if (outTokenUnderlying != address(0)) {
            assertLte(IERC20(outTokenUnderlying).balanceOf(address(sut)), 0);
        }

        assertEq(IERC20(rewardToken).balanceOf(address(sut)), 0);
        assertEq(IERC20(rewardToken).balanceOf(address(torex)), 0);

        ISuperToken inToken = torex.getConfig().inToken;

        address inTokenUnderlying = inToken.getUnderlyingToken();
        uint8 inTokenDecimals = inToken.getUnderlyingDecimals();
        if (inTokenDecimals < 18) {
            assertLte(inToken.balanceOf(address(sut)), 1_000_000_000_000);
        } else {
            assertLte(inToken.balanceOf(address(sut)), 0);
        }

        if (inTokenUnderlying != address(0)) {
            assertEq(IERC20(inTokenUnderlying).balanceOf(address(sut)), 0);
        }
        assertEq(address(sut).balance, 0);
    }
}
